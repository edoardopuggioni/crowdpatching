Tutorial to run a full circuit example

The example used is the hash preimage example, where the public (aka
non-secret or primary) input is the expected digest (provided as a
string of hexadecimal digits) and the secret input (aka auxiliary 
input) is the pre-image, provided by the prover, which is simply the
"plain-text" that will be hashed and not revealed to the verifier.


THIS TUTORIAL REFERS TO THE FILES GIVEN BY THE FOLLOWING COMMIT

Created and tested tutorial for running a whole circuit example
Commit code: 7bec2354f9e802f3e843bd9a85225a7bddcf9f8c
Commit link: https://github.com/edoardopuggioni/jsnarking/commit/7bec2354f9e802f3e843bd9a85225a7bddcf9f8c


In the following steps I will refer to "jsnark code" when indicating
the Java part of the source code, which concerns jsnark. And I will
refer to the libsnark code when indicating the C++ part of the source
code, which concerns the libsnark library or the jsnark interface to
the libsnark library.

Source code for the jsnark part can be found here:
JsnarkCircuitBuilder/src/examples/generators/

And for the libsnark part here:
libsnark/libsnark/jsnark_interface/


1. First things first: compile both the jsnark and libsnark code

   $ cd jsnarking/JsnarkCircuitBuilder/
   $ javac -d bin -cp /usr/share/java/junit4.jar:bcprov-jdk15on-159.jar  $(find ./src/* | grep ".java$")
   $ cd ../libsnark/build/
   $ make

2. Run the jsnark code for the generator G, which will produce (i) the
   keys PK and VK (exported into files with hardcoded names) and (ii)
   the .arith file, which represents the arithmentic circuit and will
   be used by the libsnark code for, again, the generator G.

   $ cd
   $ cd jsnarking/JsnarkCircuitBuilder/
   $ java -cp bin examples.generators.HashPreimageVerificationCircuitGeneratorNoEvaluation

3. After the last step, a new .arith file has been created in the 
   JsnarkCircuitBuilder directory. Now we can run the libsnark code
   for the generator G, providing the .arith file as command line
   argument. Note that the name of the file is hardcoded in Java.

   $ ~/jsnarking/libsnark/build/libsnark/jsnark_interface/generator hash_preimage_NO_EVALUATION.arith

4. In the last step, the PK and VK keys are created in the same
   directory as before, JsnarkCircuitBuilder: all the files will be
   created inside here, I will not repeat it anymore. Now we can run
   the jsnark code for the prover P.

   $ java -cp bin examples.generators.HashPreimageVerificationCircuitGenerator

5. In the previous step two new files were created: (i) another .arith
   file which is identical to the one created by the generator just
   with a different name and (ii) an input .in file. The .arith file
   is not really needed becase we already have the one produced by the
   generator G in step (2), but we use the new one to simulate the
   fact that P is independent of G, as it happens in a real-world
   scenario. Both the .arith and .in files are given as command line
   arguments to the libsnark (C++) interface of the prover P. Also
   this interface will load the proving key PK from file: the name of
   the file is hardcoded for simplicity.

   $ ~/jsnarking/libsnark/build/libsnark/jsnark_interface/prover hash_preimage.arith hash_preimage.in

6. In the last step the actual proof was created. Now it's time to run
   the libsnark code for the verifier V. Yes, that's right, there is
   no jsnark code for the verifier: it is not needed. This interface
   will take no command arguments, and the name of the files for the
   proof and the verification key are hardcoded. Also, and this is
   important, the public values (aka non-secret values or primary
   input of the NP statement) are hardcoded in this file.

   $ ~/jsnarking/libsnark/build/libsnark/jsnark_interface/verifier